<!doctype html><html><head><title>JavaScript異步編程小結 - 掬一捧</title><link rel="stylesheet" href="/stylesheets/posts.css?v=MTU2MTM3MjMwMTQz"></head><body><header></header><article><h1>JavaScript異步編程小結</h1><div class="meta"><div>编辑时间&nbsp;&nbsp;Fri Dec 16 2016 15:18:22 GMT+0800 (GMT+08:00)</div></div><p>JavaScript是單線程的，除了你的JS代码，其它操作都是并行执行的(everything runs in parallel except your code)。</p><p>在JS執行線程中進行的行為被稱作同步(Synchronous)操作，非JS執行線程執行的行為則被稱呼為異步(Asynchronous)操作。 諸如Ajax/HTTP請求、I/O操作等行為均與JS執行線程無關（由自己獨立的線程進行運作），這些行為在執行完成之後會將結果通知到JS執行線程； 因此，JS執行線程中會有個類似<code>while(true)</code>的循環，以觀察者的姿態<code>監聽</code>是否有其它線程傳遞消息過來，一旦捕獲到則執行本JS執行線程中相應的函數塊（回調）。</p><p>JavaScript事件循環不是本文的重點（<a href="https://docs.google.com/presentation/d/1-UC3cwd0KZtdSRAd6edLD-CvrOeM-IOpJYcb8rhElBY/edit?usp=sharing">JavaScript Event Loop</a>），本文僅對前端異步編程進行些許總結。個人的理解是JavaScript異步編程方式只有兩種方式：回調和觀察者模式。需要注意的是：</p><ul><li>Promises/A+ 是如何優雅地使用回調而設計的一種編程規範，本質依舊是回調</li><li>事件監聽和觀察者模式（發佈/訂閱模式）完全可以理解成是“一個孩子的不同暱稱”</li><li>Generators 是一種特性，實現函數在執行過程中暫停、並在將來的某個時刻恢復執行的功能</li><li>Generators+Promises 可以搭配漂亮的語法糖，將異步源碼寫得像同步源碼</li></ul><h3 id="callback-functions">Callback Functions</h3><p>函數式編程中有個概念叫做高階函數(Higher-order Functions)，其有個特性是一個函數可以作為另外一個函數的參數。通常我們將那個作為另外一個函數參數的函數稱呼為回調函數。</p><p>為方便描述和解釋，此處模擬一個具體的業務場景：通過Ajax方式請求<code>**/api/v1.0/user/{id}</code>接口獲取某個用戶的信息(Asynchronous behavior)，然後針對拿到的用戶信息進行後續的處理。 典型的做法是將<code>Ajax</code>異步請求之後進行的操作封裝成<code>callback()</code>函數，在接口訪問成功得到用戶信息之後再執行該函數：</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserInfoCallback</span>(<span class="hljs-params">id, callback</span>) </span>{
  $.ajax({
    <span class="hljs-attr">url</span>: <span class="hljs-string">`**/api/v1.0/user/<span class="hljs-subst">${id}</span>`</span>,
    <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> callback(<span class="hljs-literal">null</span>, data),
    <span class="hljs-attr">error</span>: <span class="hljs-function">(<span class="hljs-params">xhr, textStatus, errorThrown</span>)
      =&gt;</span> callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(textStatus), errorThrown),
  })
}
getUserInfoCallback(<span class="hljs-string">'10086'</span>, handleUserInfo)</code></pre><h3 id="promisesa">Promises/A+</h3><blockquote><p>An open standard for sound, interoperable JavaScript promises—by implementers, for implementers.</p></blockquote><p>濫用回調帶來的問題是代碼邏輯耦合度很高，面臨回調災難。Promises/A+是種合理使用回調的<strong>規範</strong>，避免回調的濫用。</p><h4 id="特點一：提供好看的api，由嵌套回調callback-hell轉向鏈式語法">特點一：提供好看的API，由嵌套回調(<a href="http://callbackhell.com/">callback hell</a>)轉向鏈式語法</h4><p>首先將請求用戶信息的Ajax異步操作包裝成一個Promise實例，後續的同步行為通過該實例對象的<code>then()</code>方法調用。</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserInfoPromise</span>(<span class="hljs-params">id</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">fulfill, reject</span>) =&gt;</span> {
    $.ajax({
      <span class="hljs-attr">url</span>: <span class="hljs-string">`**/api/v1.0/user/<span class="hljs-subst">${id}</span>`</span>,
      <span class="hljs-attr">success</span>: fulfill,
      <span class="hljs-attr">error</span>: reject,
    }) <span class="hljs-comment">// end $.ajax</span>
  }) <span class="hljs-comment">// end return</span>
} <span class="hljs-comment">// end getUserInfoPromise</span>
getUserInfoPromise(<span class="hljs-string">'10086'</span>)
  .then(<span class="hljs-function"><span class="hljs-params">userInfo</span> =&gt;</span> handleUserInfo)
  .catch(<span class="hljs-built_in">console</span>.log)</code></pre><h4 id="特點二：promises-不會與回調綁定耦合，可緩存異步操作結果">特點二：Promises 不會與回調綁定耦合，可緩存異步操作結果</h4><p>假設存在這樣的一個業務場景：獲取用戶id為<code>10086</code>的用戶信息，然後在不同的兩個階段對其異步操作獲取的用戶信息進行兩種不同的操作（分別為<code>handleUserInfo()</code>和<code>console.log()</code>）。 在兩個階段中，都需要異步操作獲取得到的<code>userInfo</code>數據，如果採用傳統回調方式，一般採用閉包的方式緩存<code>userInfo</code>或者暴力點重複進行一次Ajax異步請求。</p><p>但是採用Promise方式，則無需這些很<strong>複雜</strong>的實現方式，因為可以重複使用Promise對象。</p><pre><code class="language-js"><span class="hljs-comment">// 閉包緩存</span>
<span class="hljs-keyword">let</span> globUserInfo = <span class="hljs-literal">null</span>
getUserInfoCallback(<span class="hljs-string">'10086'</span>, userInfo =&gt; globUserInfo = userInfo)
<span class="hljs-comment">// 難以保證 globUserInfo 已經更新</span>
handleUserInfo(globUserInfo)
<span class="hljs-built_in">console</span>.log(globUserInfo)

<span class="hljs-comment">// 進行了兩次異步操作</span>
getUserInfoCallback(<span class="hljs-string">'10086'</span>, handleUserInfo)
getUserInfoCallback(<span class="hljs-string">'10086'</span>, <span class="hljs-built_in">console</span>.log)

<span class="hljs-comment">// 保存Promise對象</span>
<span class="hljs-keyword">const</span> userInfoPromise = getUserInfoPromise(<span class="hljs-string">'10086'</span>)
userInfoPromise.then(handleUserInfo)
<span class="hljs-comment">// 可以再次使用`userInfoPromise`對象</span>
userInfoPromise.then(<span class="hljs-built_in">console</span>.log)</code></pre><ul><li>這種策略和函數式編程中<a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>概念是類似的，強調<code>call-by-need</code>。</li><li>也可以對異步操作進行柯裡化(<a href="https://en.wikipedia.org/wiki/Currying">Curring</a>)暫存異步操作的結果（類似的概念還有thunk，參考<a href="https://github.com/tj/node-thunkify">node-thunkify</a>）。</li></ul><h4 id="特點三：可組合，復用">特點三：可組合，復用</h4><p>類似於函數式編程中推廣的從已有的函數中創建新函數，也可以通過已有的Promise對象生成新的Promise對象。 比如獲取多個用戶信息，可使用<code>Promise.all()</code>方法實現異步操作的組合：</p><pre><code class="language-js"><span class="hljs-keyword">const</span> promises = [<span class="hljs-string">'10010'</span>, <span class="hljs-string">'10086'</span>, <span class="hljs-string">'10000'</span>].map(
  <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(
    <span class="hljs-function">(<span class="hljs-params">fulfill, reject</span>) =&gt;</span> $.ajax({
      <span class="hljs-attr">url</span>: <span class="hljs-string">`**/api/v1.0/user/<span class="hljs-subst">${id}</span>`</span>,
      <span class="hljs-attr">success</span>: fulfill, <span class="hljs-attr">error</span>: reject,
    })
))
<span class="hljs-keyword">const</span> userInfosPromise = <span class="hljs-built_in">Promise</span>.all(promises)
  .then(<span class="hljs-built_in">console</span>.log)
  .catch(<span class="hljs-built_in">console</span>.log)</code></pre><blockquote><p>感覺上Promise/A+規範是函數式編程概念在前端領域的一次最佳實踐（回調的語法糖）。更多詳細的內容待補充。</p></blockquote><h3 id="event-emitters">Event Emitters</h3><p>事件監聽式異步編程本質上還是依賴於回調函數實現的，區別在於回調函數並不執行異步行為完成後需要的操作，而是發佈一個通知去觸發執行相應的函數。</p><pre><code class="language-js"><span class="hljs-keyword">import</span> EventEmitter <span class="hljs-keyword">from</span> <span class="hljs-string">'events'</span>
<span class="hljs-keyword">const</span> emitter = <span class="hljs-keyword">new</span> EventEmitter()
<span class="hljs-comment">// 註冊</span>
emitter.on(<span class="hljs-string">'event'</span>, handleUserInfo)
$.ajax({
  <span class="hljs-attr">url</span>: <span class="hljs-string">`**/api/v1.0/user/10086`</span>,
  <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> emitter.emit(<span class="hljs-string">'event'</span>, data), <span class="hljs-comment">// 觸發：異步操作這個行為帶來的影響</span>
  error: <span class="hljs-built_in">console</span>.log,
})</code></pre><p>事件監聽其實是觀察者模式的一種實現：當一個對象發生變化時，所有依賴他的相關操作都會得到通知，只不過事件監聽弱化了對象的變化而強調行為（對象數據變更也是一種行為）。 比如上面的代碼段強調的是Ajax操作這個行為，一旦完成就<strong>通知</strong>到<code>handleUserInfo()</code>函數的調用，並攜帶參數變更對象數據。</p><p>如果採用觀察者模式的話，一般這樣直接處理數據（強調數據變化帶來的影響，造成數據變化的場景可能存在多處），然後觸發數據變動後的行為：</p><pre><code class="language-js"><span class="hljs-keyword">let</span> userInfo = <span class="hljs-literal">null</span>
emitter.on(<span class="hljs-string">'event'</span>, () =&gt; handleUserInfo(userInfo))
<span class="hljs-keyword">const</span> updateUserInfo = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
  userInfo = data       <span class="hljs-comment">// userInfo對象方式變更</span>
  emitter.emit(<span class="hljs-string">'event'</span>) <span class="hljs-comment">// 通知相關依賴的操作：數據變更帶來的影響</span>
}
$.ajax(
  url: <span class="hljs-string">`**/api/v1.0/user/10086`</span>,
  <span class="hljs-attr">success</span>: updateUserInfo, <span class="hljs-comment">// 觸發</span>
  error: <span class="hljs-built_in">console</span>.log,
})</code></pre><p>很明顯，觀察者模式要比事件監聽方式擴充性更強（雖然本質一致，但是強調側重點不同）。</p><figure style="padding-top: 0;margin-top:-1.5em;"><img src="/images/posts/pingpong.gif" alt="containing block"><figcaption>陷入`emit`死循環</figcaption></figure>事件監聽式異步編程無異於`goto`語句，稍有不慎形如`on()`、`emit()`、`subscribe()`、`publish()`等方法摻雜在各處，“剪不清，理還亂”； 如果不是“約定”化編程不建議採用。比如下面這段源碼，稍不慎就陷入如圖1所示場景。<pre><code class="language-js"><span class="hljs-keyword">const</span> emitter = <span class="hljs-keyword">new</span> EventEmitter()
<span class="hljs-keyword">const</span> foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> emitter.emit(<span class="hljs-string">'bar'</span>)
<span class="hljs-keyword">const</span> bar = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> emitter.emit(<span class="hljs-string">'foo'</span>)
emitter.on(<span class="hljs-string">'foo'</span>, foo)
emitter.on(<span class="hljs-string">'bar'</span>, bar)
foo()    <span class="hljs-comment">// 陷入死循環</span></code></pre><p>和回調式異步編程（包括Promises/A+規範）相比，事件監聽式異步編程的軟肋在於需要手動註冊(Manual)。 原本可以通過數據綁定(Data binding)<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe">Object.observe()</a>方法來實現觀察者模式，很可惜該方法已被<code>deprecated</code>掉；目前推薦的是<code>get</code>和<code>set</code>+<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>方式實現（相關討論：<a href="http://stackoverflow.com/questions/36258502/why-object-observe-has-been-deprecated">36258502</a>）。</p><p>但是手動維護這些<code>on()</code>、<code>emit()</code>、<code>get()</code>、<code>set()</code>等方法在項目是很折騰的，通過一些第三方工具包可以實現由<code>Manual</code>到<code>Automatic</code>轉變。 比如採用<a href="http://mobxjs.github.io/mobx/index.html">MobX</a>可以實現得更加優雅：</p><pre><code class="language-js"><span class="hljs-keyword">import</span> { observable, autorun } <span class="hljs-keyword">from</span> <span class="hljs-string">'mobx'</span>
<span class="hljs-keyword">const</span> store = observable({<span class="hljs-attr">userInfo</span>: <span class="hljs-literal">null</span>})
<span class="hljs-comment">// 只要變動`store`對象，就會自動觸發`handleUserInfo()`函數</span>
autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> handleUserInfo(store.userInfo))
$.ajax(
  url: <span class="hljs-string">`**/api/v1.0/user/10086`</span>,
  <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> store.userInfo = data,
  <span class="hljs-attr">error</span>: <span class="hljs-built_in">console</span>.log,
})</code></pre><h3 id="generator">Generator</h3><h4 id="coroutine-協程-aka-co-operative-routines"><a href="https://en.wikipedia.org/wiki/Coroutine">Coroutine</a> 協程 (a.k.a. co-operative routines)</h4><p>一般程序中，函數調用一定是從頭到尾執行直到遇到<code>return</code>或執行完； 而coroutine 則容許函數執行到一半時就中斷(yield)，中斷時函數內部上下文環境(context)會被緩存下來。 程序主體可以隨時恢復(resume)這個被緩存的coroutine，繼續從剛才被中斷處執行後續內容。</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>)
  <span class="hljs-keyword">yield</span> <span class="hljs-number">10086</span>           <span class="hljs-comment">// 在此處中斷 coroutine</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'world'</span>)
}

<span class="hljs-keyword">const</span> bar = foo()                   <span class="hljs-comment">// 保存 coroutine 內部狀態的變量</span>
bar.next()                          <span class="hljs-comment">// 調用`foo()`函數，遇到 yield 中斷程序調用</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'main, not in `foo()`'</span>) <span class="hljs-comment">// 已經從`foo()`函數中跳出來了，可以幹些其它事情</span>
bar.next()                          <span class="hljs-comment">// 恢復`foo()`的調用，從 yield 中斷處繼續執行</span></code></pre><h4 id="thread-vs-coroutine">Thread VS Coroutine</h4><blockquote><p>With threads, the operating system switches running threads preemptively according to its scheduler, which is an algorithm in the operating system kernel. With coroutines, the programmer and programming language determine when to switch coroutines; in other words, tasks are cooperatively multitasked by pausing and resuming functions at set points, typically (but not necessarily) within a single thread.<br>—— <a href="http://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread">stackoverflow: difference-between-a-coroutine-and-a-thread</a></p></blockquote><h4 id="generator-aka-semicoroutines-vs-coroutine"><a href="https://en.wikipedia.org/wiki/Generator_(computer_programming)">Generator</a> (a.k.a. semicoroutines) VS Coroutine</h4><p>Generator與Coroutine 的區別是Generator 只能從上次中斷處繼續執行，而Coroutine則沒有這樣的限制（可以指定從哪裡繼續執行）。 因此，Generator可以視作是Coroutine的一種特殊情況，上文涉及的源碼例子其實就是Generator的應用舉例。 其中，Generator涉及<code>bar.next()</code>自動流程管理的解決方案可以參考<a href="https://github.com/tj/co">co</a>、<a href="https://github.com/thunks/thunks">thunks</a>等。</p><h4 id="asyncawait-語法糖">async/await “語法糖”</h4><p>聲明的<code>async</code>函數就是將Generator函數和自動執行器包裝在一個函數裡面（參考<a href="https://gist.github.com/solome/064e48f5205943dff7d4918b3bf18e0d">async2generator()</a>）， 以達到異步編碼編程模式與同步編碼一致。</p><pre><code class="language-js"><span class="hljs-keyword">const</span> run = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> userInfo = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">fulfill, reject</span>) =&gt;</span> {
    $.ajax({
      <span class="hljs-attr">url</span>: <span class="hljs-string">`**/api/v1.0/user/<span class="hljs-subst">${id}</span>`</span>,
      <span class="hljs-attr">success</span>: fulfill,
      <span class="hljs-attr">error</span>: reject,
    }) <span class="hljs-comment">// end $.ajax</span>
  }) <span class="hljs-comment">// end return</span>
  handleUserInfo(userInfo)
}</code></pre><h3 id="不是總結的總結">不是總結的總結</h3><ul><li>函數式編程領域的知識還是要多多接觸的。</li><li>有些前端領域的新鮮事物在其他領域可能就是些習以為常的東西，擴充知識面很重要。</li></ul><h3 id="references">References</h3><ul><li><a href="http://callbackhell.com/">Callback Hell</a>: A guide to writing asynchronous JavaScript programs.</li><li><a href="https://promisesaplus.com/">Promises/A+</a>: An open standard for sound, interoperable JavaScript promises—by implementers, for implementers.</li><li><a href="https://www.promisejs.org/">promisejs.org</a>: A website dedicated to promises in JavaScript.</li><li><a href="https://facebook.github.io/regenerator/">regenerator</a>: Source transformer enabling ECMAScript 6 generator functions in JavaScript-of-today.</li><li><a href="https://github.com/tc39/ecmascript-asyncawait">ecmascript-asyncawait</a>: Async/await for ECMAScript.</li><li><a href="http://devsmash.com/blog/whats-the-big-deal-with-generators">whats-the-big-deal-with-generators</a></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4287.pdf">Threads, Fibers &amp; Coroutines</a></li></ul></article><footer></footer></body></html>