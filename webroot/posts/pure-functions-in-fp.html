<!doctype html>
<html>
<head>

</head>

<body>
  <article>
    <p>数学上的函数指的是两个集合间的一种特殊的映射关系。这个特殊体现在什么地方呢？</p>
<p>我们将集合A的元素称呼为输入值，集合B的元素称呼为输出值，集合A、B存在这样的映射关系：
每个输入值只会映射一个输出值，不同的输入值可以映射相同的输出值，不会出现同一个输入值映射不同的输出值。</p>
<p>下图集合A和集合B的映射关系即符合数学函数的定义。</p>
<figure>
  <img src="/images/post/set_map.svg" alt="containing block" />
  <figcaption>fn：除以5的余数</figcaption>
</figure>


<p>在编程语言中，满足这种数学意义上的函数即为纯函数(Pure Function)：相同的输入（参数），永远得到的是相同的输出（返回值），并且没有任何可观察的副作用。
与纯函数的概念相反的函数（即相同输入却得到不同结果 或 附带副作用）叫做非纯函数(Impure Function)。</p>
<h3 id="关于函数副作用side-effect">关于函数副作用(side-effect)</h3>
<p>函数副作用 指当调用函数时，在计算返回值数值的过程中，对主调用函数产生附加的影响。</p>
<p>比如变更了更高作用域的的变量：</p>
<pre><code class="language-js"><div class="highlight"><pre><span class="kd">let</span> <span class="nx">glob</span> <span class="o">=</span> <span class="mi">1</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="nx">glob</span> <span class="o">+</span> <span class="nx">x</span> <span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1">// =&gt; 3</span>
</pre></div>
</code></pre>
<p>变量<code>glob</code>的值已发生变更，表现得很不明显。</p>
<p>“隐晦”地修改了引用参数：</p>
<pre><code class="language-js"><div class="highlight"><pre><span class="kd">let</span> <span class="nx">glob</span> <span class="o">=</span> <span class="mi">1</span>
<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">glob</span><span class="p">}</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="nx">x</span><span class="p">.</span><span class="nx">glob</span> <span class="p">}</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">glob</span><span class="p">)</span> <span class="c1">// =&gt; 2</span>
</pre></div>
</code></pre>
<p>虽然对象<code>obj</code>定义为<code>const</code>，但是修改了间接引用的变量<code>glob</code>；这种场景引发的bug其实是很难捕获的（尤其是具备指针概念的C/C++语言）。</p>
<p>函数副作用确实是滋生bug的温床，但并不意味着其一无是处；
也无需一昧追求纯函数编程，在实际编码中，我们根本无法避免函数的副作用（典型的例子是读写数据库操作的函数）。
最好的做法是，要将这些副作用限制在可控的范围内。</p>
<h3 id="纯函数带来的好处">纯函数带来的好处</h3>
<h4 id="函数调用结果可缓存">函数调用结果可缓存</h4>
<p>相同参数得到的返回值是相同的。
如果通过参数获取返回值的过程计算量过大，我们可以缓存函数调用的结果，避免相同参数为了获取返回值进行重复计算。
典型的实践是对递归函数做性能优化的memoize技术。</p>
<p>以<code>fibonacci(n)</code>递归函数为例，传统的实现：</p>
<pre><code class="language-js"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span>
  <span class="k">return</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</code></pre>
<p>计算的复杂度以参数<code>n</code>呈指数级增长：</p>
<pre><code class="language-haskell"><div class="highlight"><pre><span class="nf">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">2</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
     <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">3</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
     <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">5</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
     <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
     <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
     <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">8</span>
<span class="o">...</span> <span class="o">...</span>
</pre></div>
</code></pre>
<p>为了获取<code>fibonacci(n)</code>的结果，我们不得不将<code>fibonacci(n-1)</code>和<code>fibonacci(n-2)</code>都得计算一遍；
如果我们在调用一次<code>fibonacci(n)</code>之后，就将其缓存起来，下次再调用时就无需重新再计算。
稍加改造，添加对计算结果的缓存：</p>
<pre><code class="language-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">fibonacci</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">cache</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="k">return</span> <span class="kd">function</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="k">in</span> <span class="nx">cache</span><span class="p">)</span> <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">cache</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nx">n</span> <span class="o">:</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">})()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</code></pre>
<p>这是典型的以空间换效率的实现方案，避免了额外计算的浪费。
这样实现的前提就是，该递归函数是纯函数，相同参数得到的返回值一定是相同的；如果不能保证相同，我们无法做缓存。</p>
<p>当然，我们可以实现一个<code>memoize()</code>函数来统一做缓存这样的工作。
JavaScript函数式编程支持库如均提供<code>memoize()</code>函数，这里提供一种不太健壮（内存溢出）的实现方案。</p>
<pre><code class="language-js"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">memoize</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">memo</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="kr">const</span> <span class="nx">slice</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span>

  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">args</span> <span class="k">in</span> <span class="nx">memo</span><span class="p">)</span> <span class="k">return</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">args</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">memo</span><span class="p">[</span><span class="nx">args</span><span class="p">]</span> <span class="o">=</span> <span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<h4 id="便于移植和测试">便于移植和测试</h4>
<p>纯函数是“自给自足”的，所有的函数依赖均由函数自身提供（或参数）；因此，我们将一个函数移植到另外一个系统时，是无需考虑成本的（当然，如果一个函数依赖一个全部变量，在移植该函数时必须“慎重”，但该函数是纯函数时就无需有这样的顾虑）。</p>
<p>相同参数得到的函数返回值是固定的，这一特性也使纯函数更易测试——你无需mock或模拟出一些特殊的测试环境，只要明确定义好函数参数的范围即可。</p>
<h4 id="引用透明（referential-transparent）">引用透明（Referential Transparent）</h4>
<blockquote>
<p>An expression is said to be referentially transparent if it can be replaced with its corresponding value without changing the program&#39;s behavior. As a result, evaluating a referentially transparent function gives the same value for same arguments. Such functions are called pure functions.<br>—— <a href="https://en.wikipedia.org/wiki/Referential_transparency">https://en.wikipedia.org/wiki/Referential_transparency</a></p>
</blockquote>
<p>该如何理解呢？可以拿上文提到的<code>fibonacci()</code>函数举例，比如存在这样一个函数：</p>
<pre><code class="language-js"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">fun</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fun</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fun</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nx">fibonacci</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>调用<code>foo(10, fibonacci)</code>会发现<code>fibonacci(10)</code>被执行了两遍。因为纯函数具备引用透明性，某些表达式被<strong>替换</strong>并不会改变函数的行为；因此，对<code>foo()</code>进行些许变动会使其性能得到质的提升。</p>
<pre><code class="language-js"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">fun</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fun</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>毕竟在此场景中，一次乘法运算成本远比一次<code>fibonacci(10)</code>递归运算的成本来得低。</p>
<p>这里的由<code>fibonacci(n) + fibonacci(n) =&gt; 2*fibonacci(n)</code>转变完全跟数学概念中的<code>f(x) = x + x = 2 *x</code>函数推导一致。</p>
<p>因为纯函数的引用透明的特性，我们完全可以将多个函数构成的复杂程序（函数）<strong>推导</strong>成更加简单的方式。</p>
<h4 id="并行代码">并行代码</h4>
<p>纯函数无副作用，同时调用两个函数或同个函数被同时调用两次都不会抢占外部公共资源的情况。</p>
<h3 id="总结">总结</h3>
<ul>
<li>程序设计中的大部分bug都是有函数副作用引入的，实际开发中必须鼓励纯函数的编写（尤其在JavaScript、Python这类<strong>胶水</strong>语言中）</li>
<li>在函数式编程中，欲想以函数为基础生成新的函数，那纯函数是这些新函数的基石</li>
<li>多尝试使用memoize技术对递归函数进行性能优化</li>
</ul>

  </article>
</body>

</html>
